<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³å£°èŠ±ç«ã‚²ãƒ¼ãƒ  with AIæ„Ÿæƒ…åˆ†æ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            background: linear-gradient(135deg, #001122, #000033);
        }
        
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .controls button:hover {
            background: #45a049;
        }
        
        .controls button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .controls button.recording {
            background: #f44336;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .controls input {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            min-width: 200px;
        }
        
        .controls input::placeholder {
            color: #aaa;
        }
        
        .status {
            font-size: 12px;
            color: #aaa;
            margin-left: 10px;
        }
        
        .sentiment-display {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 12px;
        }
        
        .sentiment-score {
            font-weight: bold;
            font-size: 14px;
        }
        
        .sentiment-label {
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sentiment-confidence {
            color: #aaa;
        }
        
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 12px;
        }
        
        .audio-controls button {
            padding: 6px 10px;
            border: none;
            border-radius: 3px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .audio-controls button:hover {
            background: #45a049;
        }
        
        .audio-controls button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .audio-controls button.active {
            background: #f44336;
        }
        
        .audio-controls button.muted {
            background: #ff9800;
        }
        
        .volume-slider {
            width: 60px;
            height: 4px;
            background: #555;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .track-info {
            font-size: 10px;
            color: #aaa;
            min-width: 80px;
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls input {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <button id="micBtn">ğŸ¤ éŸ³å£°èªè­˜é–‹å§‹</button>
        <input type="text" id="textInput" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" maxlength="50">
        <button id="launchBtn">ğŸ† æ‰“ã¡ä¸Šã’</button>
        <div class="status" id="status">æº–å‚™å®Œäº†</div>
        <div class="sentiment-display" id="sentimentDisplay" style="display: none;">
            <span class="sentiment-score" id="sentimentScore">-</span>
            <span class="sentiment-label" id="sentimentLabel">-</span>
            <span class="sentiment-confidence" id="sentimentConfidence">-</span>
        </div>
        <div class="audio-controls" id="audioControls">
            <button id="playPauseBtn" title="å†ç”Ÿ/åœæ­¢">â–¶ï¸</button>
            <button id="prevTrackBtn" title="å‰ã®ãƒˆãƒ©ãƒƒã‚¯">â®ï¸</button>
            <button id="nextTrackBtn" title="æ¬¡ã®ãƒˆãƒ©ãƒƒã‚¯">â­ï¸</button>
            <button id="muteBtn" title="ãƒŸãƒ¥ãƒ¼ãƒˆ">ğŸ”Š</button>
            <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="30" title="éŸ³é‡">
            <div class="track-info" id="trackInfo">BGMåœæ­¢ä¸­</div>
        </div>
    </div>

    <!-- å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®èª­ã¿è¾¼ã¿ -->
    <script src="config.js"></script>
    <script src="sentiment-api.js"></script>
    <script src="audio-service.js"></script>

    <script>
        // å®šæ•°å®šç¾©
        const CONFIG = {
            DOT_GAP: 3,           // ãƒ‰ãƒƒãƒˆã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”
            HOLD_MS: 1000,        // æ–‡å­—å½¢çŠ¶ã‚’ä¿æŒã™ã‚‹æ™‚é–“
            SPREAD_SPEED: 2,      // æ‹¡æ•£é€Ÿåº¦
            FADE_SPEED: 0.02,     // ãƒ•ã‚§ãƒ¼ãƒ‰é€Ÿåº¦
            MAX_LIFE: 1.0,        // ç²’å­ã®æœ€å¤§å¯¿å‘½
            FONT_SIZE_BASE: 120,  // ãƒ™ãƒ¼ã‚¹ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º
            FONT_SIZE_MIN: 40,    // æœ€å°ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º
            MAX_TEXT_WIDTH: 0.8   // ç”»é¢å¹…ã«å¯¾ã™ã‚‹æœ€å¤§ãƒ†ã‚­ã‚¹ãƒˆå¹…
        };

        // è¨­å®šã®åˆæœŸåŒ–
        let isApiConfigured = false;
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«è¨­å®šã‚’åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof initializeConfig === 'function') {
                isApiConfigured = initializeConfig();
            }
            
            if (!isApiConfigured) {
                console.warn('APIè¨­å®šãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚config.jsãƒ•ã‚¡ã‚¤ãƒ«ã§APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚');
            }
        });

        class Particle {
            constructor(x, y, color = null) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.life = CONFIG.MAX_LIFE;
                this.phase = 'hold'; // 'hold' -> 'spread'
                this.color = color || `hsl(${Math.random() * 60 + 30}, 100%, 70%)`;
            }

            update() {
                if (this.phase === 'spread') {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= CONFIG.FADE_SPEED;
                }
            }

            startSpread() {
                this.phase = 'spread';
                this.vx = (Math.random() - 0.5) * CONFIG.SPREAD_SPEED * 4;
                this.vy = (Math.random() - 0.5) * CONFIG.SPREAD_SPEED * 4;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
                ctx.globalAlpha = 1;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        class FireworksGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.queue = [];
                this.isPlaying = false;
                this.currentShow = null;
                
                this.recognition = null;
                this.isRecording = false;
                this.currentSentiment = null;
                
                this.init();
            }

            init() {
                this.setupCanvas();
                this.setupSpeechRecognition();
                this.setupEventListeners();
                this.setupAudioControls();
                this.startGameLoop();
                
                window.addEventListener('resize', this.debounce(() => {
                    this.setupCanvas();
                }, 250));
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupSpeechRecognition() {
                if ('webkitSpeechRecognition' in window) {
                    this.recognition = new webkitSpeechRecognition();
                    this.recognition.lang = 'ja-JP';
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;

                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        this.updateUI();
                        this.setStatus('éŸ³å£°ã‚’èªè­˜ä¸­...');
                    };

                    this.recognition.onresult = (event) => {
                        const text = event.results[0][0].transcript;
                        this.setStatus(`èªè­˜: "${text}"`);
                        this.processText(text);
                    };

                    this.recognition.onerror = (event) => {
                        this.setStatus(`ã‚¨ãƒ©ãƒ¼: ${event.error}`);
                        this.isRecording = false;
                        this.updateUI();
                    };

                    this.recognition.onend = () => {
                        this.isRecording = false;
                        this.updateUI();
                    };
                } else {
                    this.setStatus('éŸ³å£°èªè­˜ã¯éå¯¾å¿œã§ã™ã€‚ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
                    document.getElementById('micBtn').disabled = true;
                }
            }

            setupEventListeners() {
                document.getElementById('micBtn').addEventListener('click', () => {
                    if (this.isRecording) {
                        this.recognition.stop();
                    } else {
                        this.recognition.start();
                    }
                });

                document.getElementById('launchBtn').addEventListener('click', () => {
                    const text = document.getElementById('textInput').value.trim();
                    if (text) {
                        this.processText(text);
                        document.getElementById('textInput').value = '';
                    }
                });

                document.getElementById('textInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('launchBtn').click();
                    }
                });
            }

            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¨­å®š
            setupAudioControls() {
                // å†ç”Ÿ/åœæ­¢ãƒœã‚¿ãƒ³
                document.getElementById('playPauseBtn').addEventListener('click', async () => {
                    try {
                        if (audioService.isPlaying) {
                            await audioService.stop();
                        } else {
                            await audioService.play();
                        }
                        this.updateAudioUI();
                    } catch (error) {
                        console.error('BGMæ“ä½œã‚¨ãƒ©ãƒ¼:', error);
                        this.setStatus('BGMæ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                });

                // å‰ã®ãƒˆãƒ©ãƒƒã‚¯ãƒœã‚¿ãƒ³
                document.getElementById('prevTrackBtn').addEventListener('click', async () => {
                    try {
                        await audioService.previousTrack();
                        this.updateAudioUI();
                    } catch (error) {
                        console.error('ãƒˆãƒ©ãƒƒã‚¯å¤‰æ›´ã‚¨ãƒ©ãƒ¼:', error);
                        this.setStatus('ãƒˆãƒ©ãƒƒã‚¯å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                });

                // æ¬¡ã®ãƒˆãƒ©ãƒƒã‚¯ãƒœã‚¿ãƒ³
                document.getElementById('nextTrackBtn').addEventListener('click', async () => {
                    try {
                        await audioService.nextTrack();
                        this.updateAudioUI();
                    } catch (error) {
                        console.error('ãƒˆãƒ©ãƒƒã‚¯å¤‰æ›´ã‚¨ãƒ©ãƒ¼:', error);
                        this.setStatus('ãƒˆãƒ©ãƒƒã‚¯å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                });

                // ãƒŸãƒ¥ãƒ¼ãƒˆãƒœã‚¿ãƒ³
                document.getElementById('muteBtn').addEventListener('click', () => {
                    const isMuted = audioService.toggleMute();
                    this.updateAudioUI();
                });

                // éŸ³é‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    audioService.setVolume(volume);
                    this.updateAudioUI();
                });

                // åˆæœŸUIæ›´æ–°
                this.updateAudioUI();
            }

            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªUIã®æ›´æ–°
            updateAudioUI() {
                const status = audioService.getStatus();
                const playPauseBtn = document.getElementById('playPauseBtn');
                const muteBtn = document.getElementById('muteBtn');
                const volumeSlider = document.getElementById('volumeSlider');
                const trackInfo = document.getElementById('trackInfo');

                // å†ç”Ÿ/åœæ­¢ãƒœã‚¿ãƒ³
                if (status.isPlaying) {
                    playPauseBtn.textContent = 'â¸ï¸';
                    playPauseBtn.classList.add('active');
                } else {
                    playPauseBtn.textContent = 'â–¶ï¸';
                    playPauseBtn.classList.remove('active');
                }

                // ãƒŸãƒ¥ãƒ¼ãƒˆãƒœã‚¿ãƒ³
                if (status.isMuted) {
                    muteBtn.textContent = 'ğŸ”‡';
                    muteBtn.classList.add('muted');
                } else {
                    muteBtn.textContent = 'ğŸ”Š';
                    muteBtn.classList.remove('muted');
                }

                // éŸ³é‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
                volumeSlider.value = Math.round(status.volume * 100);

                // ãƒˆãƒ©ãƒƒã‚¯æƒ…å ±
                if (status.isPlaying) {
                    trackInfo.textContent = `${status.currentTrackName} (${status.currentTrackIndex + 1}/${status.totalTracks})`;
                } else {
                    trackInfo.textContent = 'BGMåœæ­¢ä¸­';
                }
            }

            textToParticles(text, sentiment = null) {
                // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å‹•çš„ã«èª¿æ•´
                let fontSize = CONFIG.FONT_SIZE_BASE;
                const maxWidth = this.canvas.width * CONFIG.MAX_TEXT_WIDTH;
                
                // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã§ãƒ†ã‚­ã‚¹ãƒˆå¹…ã‚’æ¸¬å®š
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                do {
                    tempCtx.font = `bold ${fontSize}px sans-serif`;
                    const metrics = tempCtx.measureText(text);
                    if (metrics.width <= maxWidth || fontSize <= CONFIG.FONT_SIZE_MIN) {
                        break;
                    }
                    fontSize -= 10;
                } while (fontSize > CONFIG.FONT_SIZE_MIN);

                // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
                tempCanvas.width = maxWidth + 100;
                tempCanvas.height = fontSize + 50;
                tempCtx.font = `bold ${fontSize}px sans-serif`;
                tempCtx.fillStyle = 'white';
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);

                // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                const particles = [];

                // ç”»é¢ä¸­å¤®ã«é…ç½®ã™ã‚‹ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
                const offsetX = (this.canvas.width - tempCanvas.width) / 2;
                const offsetY = (this.canvas.height - tempCanvas.height) / 2;

                // æ„Ÿæƒ…ã«åŸºã¥ãè‰²ã‚’æ±ºå®š
                let baseColor = `hsl(${Math.random() * 60 + 30}, 100%, 70%)`; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²
                if (sentiment && sentiment.color) {
                    baseColor = sentiment.color.hex;
                    // ã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦è‰²ã®é®®ã‚„ã‹ã•ã‚’èª¿æ•´
                    const score = sentiment.score;
                    const normalizedScore = (score - 1) / 9; // 0-1ã«æ­£è¦åŒ–
                    const brightness = 0.5 + (normalizedScore * 0.5); // 0.5-1.0ã®ç¯„å›²
                    baseColor = sentimentService.adjustColorBrightness(baseColor, brightness);
                }

                // ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦ç²’å­ã‚’ç”Ÿæˆ
                for (let y = 0; y < tempCanvas.height; y += CONFIG.DOT_GAP) {
                    for (let x = 0; x < tempCanvas.width; x += CONFIG.DOT_GAP) {
                        const index = (y * tempCanvas.width + x) * 4;
                        const alpha = data[index + 3];
                        
                        if (alpha > 128) { // é€æ˜åº¦ãŒ50%ä»¥ä¸Šã®å ´åˆ
                            particles.push(new Particle(
                                x + offsetX,
                                y + offsetY,
                                baseColor
                            ));
                        }
                    }
                }

                return particles;
            }

            async processText(text) {
                this.setStatus('æ„Ÿæƒ…åˆ†æä¸­...');
                
                try {
                    // æ„Ÿæƒ…åˆ†æã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ç¢ºèª
                    if (typeof sentimentService === 'undefined') {
                        throw new Error('æ„Ÿæƒ…åˆ†æã‚µãƒ¼ãƒ“ã‚¹ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                    }
                    
                    const serviceStatus = sentimentService.getStatus();
                    if (!serviceStatus.isInitialized || !serviceStatus.hasApiKey) {
                        throw new Error('APIè¨­å®šãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚config.jsãƒ•ã‚¡ã‚¤ãƒ«ã§APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚');
                    }
                    
                    // æ„Ÿæƒ…åˆ†æã‚’å®Ÿè¡Œ
                    const sentiment = await sentimentService.analyzeSentiment(text);
                    this.currentSentiment = sentiment;
                    
                    // UIã«çµæœã‚’è¡¨ç¤º
                    this.updateSentimentDisplay(sentiment);
                    
                    // èŠ±ç«ã‚’è¡¨ç¤º
                    this.show(text, sentiment);
                    
                } catch (error) {
                    console.error('æ„Ÿæƒ…åˆ†æã‚¨ãƒ©ãƒ¼:', error);
                    this.setStatus(`æ„Ÿæƒ…åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                    
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²ã§è¡¨ç¤º
                    this.show(text, null);
                }
            }

            show(text, sentiment = null) {
                this.queue.push({ text, sentiment });
                if (!this.isPlaying) {
                    this.processQueue();
                }
            }

            async processQueue() {
                if (this.queue.length === 0) {
                    this.isPlaying = false;
                    return;
                }

                this.isPlaying = true;
                const { text, sentiment } = this.queue.shift();
                
                // æ–°ã—ã„ç²’å­ã‚’ç”Ÿæˆ
                this.particles = this.textToParticles(text, sentiment);
                
                // ä¿æŒãƒ•ã‚§ãƒ¼ã‚º
                await this.sleep(CONFIG.HOLD_MS);
                
                // æ‹¡æ•£ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹
                this.particles.forEach(particle => particle.startSpread());
                
                // æ‹¡æ•£å®Œäº†ã¾ã§å¾…æ©Ÿ
                await this.waitForSpreadComplete();
                
                // æ¬¡ã®ã‚­ãƒ¥ãƒ¼ã‚’å‡¦ç†
                this.processQueue();
            }

            waitForSpreadComplete() {
                return new Promise(resolve => {
                    const checkComplete = () => {
                        if (this.particles.every(p => p.isDead())) {
                            resolve();
                        } else {
                            requestAnimationFrame(checkComplete);
                        }
                    };
                    checkComplete();
                });
            }

            startGameLoop() {
                const loop = () => {
                    this.update();
                    this.draw();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            update() {
                this.particles.forEach(particle => particle.update());
                this.particles = this.particles.filter(particle => !particle.isDead());
            }

            draw() {
                // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç²’å­ã‚’æç”»
                this.particles.forEach(particle => particle.draw(this.ctx));
            }

            updateUI() {
                const micBtn = document.getElementById('micBtn');
                if (this.isRecording) {
                    micBtn.textContent = 'ğŸ›‘ åœæ­¢';
                    micBtn.classList.add('recording');
                } else {
                    micBtn.textContent = 'ğŸ¤ éŸ³å£°èªè­˜é–‹å§‹';
                    micBtn.classList.remove('recording');
                }
            }

            setStatus(message) {
                document.getElementById('status').textContent = message;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }


            // æ„Ÿæƒ…åˆ†æçµæœã®UIæ›´æ–°
            updateSentimentDisplay(sentiment) {
                const display = document.getElementById('sentimentDisplay');
                const score = document.getElementById('sentimentScore');
                const label = document.getElementById('sentimentLabel');
                const confidence = document.getElementById('sentimentConfidence');

                score.textContent = sentiment.score;
                label.textContent = sentiment.labelJa;
                confidence.textContent = `ä¿¡é ¼åº¦: ${(sentiment.confidence * 100).toFixed(0)}%`;

                // è‰²ã«å¿œã˜ã¦ã‚¹ã‚³ã‚¢ã®è‰²ã‚’å¤‰æ›´
                score.style.color = sentiment.color.hex;

                display.style.display = 'flex';
            }
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        window.addEventListener('DOMContentLoaded', () => {
            new FireworksGame();
        });
    </script>
</body>
</html>
